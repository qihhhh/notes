# 1. 分布式锁介绍

## 1.1 什么是分布式锁

在分布式环境下，多个程序/线程都需要对某一份数据进行修改时，针对程序进行控制，保证同一时间节点下只有一个程序/线程对数据进行操作的技术。

## 1.2 分布式锁的真实场景

**场景一**：

![image-20200626150658107](C:\Users\qihang\AppData\Roaming\Typora\typora-user-images\image-20200626150658107.png)

**场景二**：

![image-20200626151112087](C:\Users\qihang\AppData\Roaming\Typora\typora-user-images\image-20200626151112087.png)

## 1.3 分布式锁的执行流程

![image-20200626151723816](C:\Users\qihang\AppData\Roaming\Typora\typora-user-images\image-20200626151723816.png)

## 1.4 分布式锁具备的条件

<img src="C:\Users\qihang\AppData\Roaming\Typora\typora-user-images\image-20200626151957584.png" alt="image-20200626151957584" style="zoom:150%;" />

 # 2. 分布式锁的实现

## 2.1 数据库实现分布式锁

### 2.1.1 基于数据库表的实现

* 准备工作：创建tb_program表用于记录当前哪个程序正在使用数据

![image-20200626160720705](C:\Users\qihang\AppData\Roaming\Typora\typora-user-images\image-20200626160720705.png)

* 实现步骤：

1. 程序访问数据时，将程序的编号或方法名等存入tb_program表；
2. 插入成功则代表获取锁成功则可以执行逻辑
3. 当程序编号或方法名相同的其他程序进行插入，由于主键冲突会导致插入失败，代表获取锁失败
4. 获取锁成功的程序在执行完之后，删除该数据代表释放锁。

### 2.1.2 基于数据库排他锁（写锁）的实现

基于Mysql的Inodb引擎可以通过数据库的排他锁来实现分布式锁。

![image-20200626161947947](C:\Users\qihang\AppData\Roaming\Typora\typora-user-images\image-20200626161947947.png)

* 实现步骤：

1. 实现一个带有for update查询，锁定某行数据
2. 数据处理
3. 进行commit操作释放锁，其他的连接可以继续操作该数据

## 2.2 Redis实现分布式锁

### 2.2.1 基于setnx、expire两个命令来实现

基于setnx（set if not exist）的特点，当缓存里key不存在时，才会去set，否则直接返回false。如果返回true则获取到锁，否则获取锁失败，为了防止死锁，我们再用expire命令对这个key设置一个超时时间来避免。但是这里看似完美，实则有缺陷，当我们setnx成功后，线程发生异常中断，expire还没来的及设置，那么就会产生死锁。

解决上述问题有两种方案

第一种是采用redis2.6.12版本以后的set，它提供了一系列选项

- EX seconds – 设置键key的过期时间，单位时秒
- PX milliseconds – 设置键key的过期时间，单位时毫秒
- NX – 只有键key不存在的时候才会设置key的值
- XX – 只有键key存在的时候才会设置key的值

第二种采用setnx()，get()，getset()实现，大体的实现过程如下：

(1) 线程Asetnx，值为超时的时间戳(t1)，如果返回true，获得锁。

(2) 线程B用get 命令获取t1，与当前时间戳比较，判断是否超时，没超时false，如果已超时执行步骤3

(3) 计算新的超时时间t2，使用getset命令返回t3(这个值可能其他线程已经修改过)，如果t1==t3,获得锁,如果t1!=t3说明锁被其他线程获取了

(4) 获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）

### 2.2.2 RedLock算法

redlock算法是redis作者推荐的一种分布式锁实现方式，算法的内容如下：

(1) 获取当前时间；

(2) 尝试从5个相互独立redis客户端获取锁；

(3) 计算获取所有锁消耗的时间，当且仅当客户端从多数节点获取锁，并且获取锁的时间小于锁的有效时间，认为获得锁；

(4) 重新计算有效期时间，原有效时间减去获取锁消耗的时间；

(5) 删除所有实例的锁

redlock算法相对于单节点redis锁可靠性要更高，但是实现起来条件也较为苛刻。

(1) 必须部署5个节点才能让Redlock的可靠性更强。

(2) 需要请求5个节点才能获取到锁，通过Future的方式，先并发向5个节点请求，再一起获得响应结果，能缩短响应时间，不过还是比单节点redis锁要耗费更多时间。

然后由于必须获取到5个节点中的3个以上，所以可能出现获取锁冲突，即大家都获得了1-2把锁，结果谁也不能获取到锁，这个问题，redis作者借鉴了raft算法的精髓，通过冲突后在随机时间开始，可以大大降低冲突时间，但是这问题并不能很好的避免，特别是在第一次获取锁的时候，所以获取锁的时间成本增加了。

如果5个节点有2个宕机，此时锁的可用性会极大降低，首先必须等待这两个宕机节点的结果超时才能返回，另外只有3个节点，客户端必须获取到这全部3个节点的锁才能拥有锁，难度也加大了。

如果出现网络分区，那么可能出现客户端永远也无法获取锁的情况，介于这种情况，下面我们来看一种更可靠的分布式锁zookeeper锁。

